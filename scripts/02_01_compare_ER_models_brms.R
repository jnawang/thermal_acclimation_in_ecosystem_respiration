# This script simulates ecosystem respiration using multiple models.
# The models we tested: 
# (1) Modified Arrhenius method using a moving window of 2-week ~ 1-month; suggested by reviewers
# (2) Quadratic exponential without water or daytime NEE terms
# (3) Quadratic exponential with water term only
# (4) Quadratic exponential with daytime NEE term only
# (5) Quadratic exponential with both water and daytime NEE term

# It uses two .RDS files generated by scripts 01_02 and 01_03

# Junna Wang, Aug. 2025
#  It will take ** minutes to finish running this script. 

# pay attention:
 

library(librarian)
shelf(dplyr, lubridate, gslnls, caret, performance, ggpubr, ggplot2, zoo)
rm(list=ls())

####################Attention: change this directory based on your own directory of raw data
dir_rawdata <- '/Volumes/MaloneLab/Research/Stability_Project/Thermal_Acclimation'
####################End Attention

site_info <- read.csv('data/site_info.csv')
feature_gs <- read.csv('data/growing_season_feature_EuropFlux.csv')
feature_gs_AmeriFlux <- read.csv('data/growing_season_feature_AmeriFlux.csv')
feature_gs <- rbind(feature_gs, feature_gs_AmeriFlux)

# a data frame to store model performance
ER_model_performance <- data.frame(siteID=character(), year = integer(), RMSE_window=double(), Rsquared_window=double(),
                                   RMSE_base=double(), Rsquared_base=double(), RMSE_water=double(), Rsquared_water=double(), 
                                   RMSE_gpp=double(), Rsquared_gpp=double(), RMSE_water_gpp=double(), Rsquared_water_gpp=double())

isite_year <- 0
for (id in 1:nrow(site_info)) {
  # id = 59  # nrow(site_info) # 1, 6, 77, 89, 64, 
  print(id)
  name_site <- site_info$site_ID[id]
  print(name_site)
  
  # only use sites with SWC and GPP partition
  if (!site_info$SWC_use[id] == 'YES') {
    next
  }
  if (site_info$source[id] %in% c("AmeriFlux_BASE", "AmeriFlux_FLUXNET")) {
    next
  }
  #
  path <- file.path(dir_rawdata, "RespirationData", paste0(name_site, '_nightNEE.RDS'))
  if (file.exists(path)) {
    a_measure_night_complete <- readRDS(path)
    ac <- readRDS(file.path(dir_rawdata, "RespirationData", paste0(name_site, '_ac.RDS')))
  } else {
    next
  }

  # use TA for ER models to address reviewer's comments; Junna added to test different models
  # ac$TS <- ac$TA
  # a_measure_night_complete$TA[is.na(a_measure_night_complete$TA)] <- a_measure_night_complete$TS[is.na(a_measure_night_complete$TA)]
  # a_measure_night_complete$TS <- a_measure_night_complete$TA
  
# get daytime NEE for each day
  # Junna temporary change, need to go back. 08-16-2025
  if (name_site %in% c('US-ICt', 'US-ICh', "US-ICs")) {
    ac$daytime[is.na(ac$daytime) & between(ac$MONTH, 4, 8)] <- TRUE
    ac$daytime[is.na(ac$daytime) & !between(ac$MONTH, 4, 8)] <- FALSE
    #
    next
  }
  
  dt = 30  # minute
  if (ac$MINUTE[2] - ac$MINUTE[1] != 30) { dt = 60 }   # minutes 
  # unit is g C / m2 / day
  ac_day <- ac %>% filter(daytime) %>% group_by(YEAR, DOY) %>% 
    summarise(NEE_daytime1 = max(-sum(NEE_uStar_f, na.rm=T) * dt * 60 * 12 / 1000000, 0.0), .groups = "drop")
  # get rolling average daytime NEE of the prior 2, 3, 5, 7, 10, 14 and 20 days: NEE_daytime2, NEE_daytime3, NEE_daytime5, NEE_daytime7, NEE_daytime14
  window_sizes <- c(2, 3, 5, 7, 10, 14, 20)
  ac_day[paste0("NEE_daytime", window_sizes)] <- lapply(
    window_sizes,
    function(w) rollapply(ac_day$NEE_daytime1, width = w, FUN = mean,
                          align = "right", fill = ac_day$NEE_daytime1[1])
    )
  # add rolling average GPP
  if ("GPP_DT" %in% names(ac)) {
    ac_day <- ac %>% filter(daytime) %>% group_by(YEAR, DOY) %>% 
      summarise(GPP_DT1 = sum(GPP_DT, na.rm=T) * dt * 60 * 12 / 1000000, .groups = "drop") %>%
      right_join(ac_day, by = c("YEAR", "DOY"))
    
    ac_day[paste0("GPP_DT", window_sizes)] <- lapply(
      window_sizes,
      function(w) rollapply(ac_day$GPP_DT1, width = w, FUN = mean,
                            align = "right", fill = ac_day$GPP_DT1[1])
    )
  }
  
  # attach it to nighttime data
  if (!"NEE_daytime1" %in% names(a_measure_night_complete)) {
    a_measure_night_complete <- a_measure_night_complete %>% mutate(DOY_gpp = case_when(HOUR >= 12 ~ DOY,
                                                                                        HOUR < 12 ~ DOY - 1)) %>%
      left_join(ac_day, by = c("YEAR", "DOY_gpp"="DOY")) %>% select(-"DOY_gpp")
  }

  # gap fill the first few values
  window_sizes <- c(1, window_sizes)
  idx <- which(!is.na(a_measure_night_complete$NEE_daytime1))[1]
  a_measure_night_complete[1:idx, paste0("NEE_daytime", window_sizes)] <- a_measure_night_complete$NEE_daytime1[idx]
  if ("GPP_DT" %in% names(ac)) {
    idx <- which(!is.na(a_measure_night_complete$GPP_DT1))[1]
    a_measure_night_complete[1:idx, paste0("GPP_DT", window_sizes)] <- a_measure_night_complete$GPP_DT1[idx]
  }
  
# ----build a ER model for each site-year---- 
  # Add growing_year for sites in southern hemisphere
  a_measure_night_complete <- a_measure_night_complete  %>% 
    mutate(growing_year = case_when(DOY <= 366 ~ YEAR, 
                                    TRUE ~ YEAR - 1))

  iStart = a_measure_night_complete$YEAR[1]
  iEnd   = a_measure_night_complete$YEAR[nrow(a_measure_night_complete)]
  
  # sites in southern hemisphere lose one year, because growing season crosses two years
  if (name_site %in% c('AU-Tum', 'ZA-Kru', "BR-Sa1")) {
    iEnd <- iEnd - 1
  }
  
  # get start and end dates of growing season
  gStart <- feature_gs$gStart[feature_gs$site_ID == name_site]
  gEnd <- feature_gs$gEnd[feature_gs$site_ID == name_site]
  
  # # Junna temporary
  # gStart <- 100
  # gEnd <- 120
  
  # # decide which formula to use based on if water is used. 
  # # model 2: quadratic exponential (!the best model!)
  # if (site_info$SWC_use[id] == 'YES') {
  #   frmu   <- NEE ~ C_pool * exp(exp(alpha) * TS + beta*TS^2)  * SWC / (SWC + Hs)
  # } else {
  #   frmu   <- NEE ~ C_pool * exp(exp(alpha) * TS + beta*TS^2)
  # }  
  # stprm  <- c(C_pool=20, alpha=-1, beta=-0.01)            
  # 
  # # These initial values need to be adjusted for some sites. 
  # if (name_site == 'GF-Guy') {
  #   stprm  <- c(C_pool=20, alpha=-1, beta=-0.001)
  # }
  
  # Set up ER equation formula and initial parameter values for each model
  frmu <- list()
  stprm <- list()
  
  priors_temp1 <- brms::prior("normal(2, 5)", nlpar = "C0", lb = 0, ub = 20) +
    brms::prior("normal(0.1, 0.5)", nlpar = "alpha", lb = 0, ub = 0.2) 
  
  priors_temp2 <- priors_temp1 + 
    brms::prior("normal(-0.001, 0.1)", nlpar = "beta", lb = -0.01, ub = 0.01)
  
  priors_temp_water <- priors_temp2 +
    brms::prior("normal(10, 10)", nlpar = "Hs", lb = 0, ub = 1000) 
  
  priors_temp_gpp <- priors_temp2 +
    brms::prior("normal(0.2, 1)", nlpar = "k2", lb = 0, ub = 1) 
  
  priors_temp_water_gpp_temp <- priors_temp_water + 
    brms::prior("normal(0.2, 1)", nlpar = "k2", lb = 0, ub = 1) +
    brms::prior("normal(0.05, 0.5)", nlpar = "gamma", lb = 0, ub = 0.2)
  
  # mod1
  frmu[[1]]   <- NEE ~ C0 * exp(- alpha * (1/(15+46.02) - 1/(TS+46.02)))
  stprm[[1]]  <- priors_temp1
  
  # mod2
  frmu[[2]]   <- NEE ~ C0 * exp(alpha * TS + beta*TS^2)
  stprm[[2]]  <- priors_temp2
  
  # mod3
  frmu[[3]]   <- NEE ~ C0 * exp(alpha * TS + beta*TS^2) * SWC / (Hs + SWC)
  stprm[[3]]  <- priors_temp_water

  # mod4
  frmu[[4]]   <- NEE ~ exp(alpha * TS + beta*TS^2) * (C0 + NEE_daytime1 * k2)
  stprm[[4]]  <- priors_temp_gpp
  
  # mod5
  for (iwindow in 1:length(window_sizes)) {
    varname <- paste0("NEE_daytime", window_sizes[iwindow])
    frmu[[4 + iwindow]] <- as.formula(paste0("NEE ~ exp(alpha * TS + beta*TS^2) * C0 * SWC / (Hs + SWC) + k2 * ", varname, " * exp(gamma * TS)"))
    stprm[[4 + iwindow]] <- priors_temp_water_gpp_temp
  }

  if ("GPP_DT" %in% names(ac)) {
    for (iwindow in 1:length(window_sizes)) {
      # Store the formula and the starting parameter vector
      varname <- paste0("GPP_DT", window_sizes[iwindow])
      frmu[[4 + length(window_sizes) + iwindow]] <- as.formula(paste0("NEE ~ exp(alpha * TS + beta*TS^2) * C0 * SWC / (Hs + SWC) + k2 * ", varname, " * exp(gamma * TS)"))
      # frmu[[4 + length(window_sizes) + iwindow]] <- as.formula(paste0("NEE ~ exp(exp(alpha) * TS + beta*TS^2) * (C0 + ",
      #                                          varname, " * k2) * SWC / (exp(Hs) + SWC)"))
                                               # varname, "/(Hc + ", varname, ") * k2) * SWC / (exp(Hs) + SWC)"))
      # Half-saturation of GPP
      # frmu[[4 + length(window_sizes) + iwindow]] <- as.formula(paste0("NEE ~ exp(exp(alpha) * TS + beta*TS^2) * C0 * SWC / (Hs + SWC) * ", varname, "/(Hc + ", varname, ")"))
      stprm[[4 + length(window_sizes) + iwindow]] <- priors_temp_water_gpp_temp
    }
  }
  
  
  # C0 <- data.frame(matrix(NA, nrow = 560, ncol = iEnd - iStart + 1))
  # alpha <- data.frame(matrix(NA, nrow = 560, ncol = iEnd - iStart + 1))
  # loop through each year
  for (iyear in iStart:iEnd) {
    data <- a_measure_night_complete %>% filter(growing_year==iyear) %>% filter(between(DOY, gStart - 15, gEnd + 15))
    if (site_info$SWC_use[id] == 'YES') {
      data <- data %>% filter(!is.na(SWC))
    }
    if (nrow(data) <= 10) { next }
    print(iyear)
    isite_year <- isite_year + 1
    ER_model_performance[isite_year, 1] <- name_site
    ER_model_performance[isite_year, 2] <- iyear
    idx <- which(between(data$DOY, gStart, gEnd))
    plot(data$TS[idx], data$NEE[idx], main = iyear)
    ################################### mod1: moving-window method; 
    # smaller window, more accurate results
    measurement_thresh <- min(50, nrow(data))  # we need to have at least 50 points for each window
    days <- sort(unique(data$DOY))
    ER_mod1 <- data.frame(DOY = integer(), HOUR = integer(), MINUTE = integer(), NEE_mod1 = double())
    for (iday in 1:length(days)) {
      # use at least 100 measurements within 15 days (7 days before and 7 days after)
      nmeasurement = 0
      window = 7
      while (nmeasurement < measurement_thresh) {
        data_subset <- data %>% filter(between(DOY, days[iday] - window, days[iday] + window))
        nmeasurement <- nrow(data_subset)
        window <- window + 3
      }
      # print(window)
      # estimate model parameters
      mod1 <- brms::brm(brms::bf(frmu[[1]], alpha+C0 ~ 1, nl = TRUE),
                        prior = stprm[[1]], data = data_subset, iter = 2000, cores =2, chains = 4, backend = "cmdstanr", 
                        control = list(adapt_delta = 0.95, max_treedepth = 15), refresh = 0)
      data_day <- data_subset %>% filter(DOY == days[iday])

      data_day$NEE_mod1 <- fitted(mod1, newdata=data_day)[, "Estimate"]
      
      
      # C0[days[iday], iyear-iStart+1] <- coefficients(mod1)[1]
      # alpha[days[iday], iyear-iStart+1] <- coefficients(mod1)[2]
      
      # put predicted ER into data frame
      ER_mod1 <- rbind(ER_mod1, data_day[, c("DOY", "HOUR", "MINUTE", "NEE_mod1")])
    }
    data <- left_join(data, ER_mod1, by = c("DOY", "HOUR", "MINUTE"))
    #
    ER_model_performance[isite_year, 3:4] <- postResample(pred=data$NEE_mod1[idx], obs=data$NEE[idx])[1:2]
    # 
    # ######################Model 2: quadratic exponential without water or daytime NEE terms
    mod2 <- brms::brm(brms::bf(frmu[[2]], alpha+beta+C0 ~ 1, nl = TRUE),
              prior = stprm[[2]], data = data, iter = 2000, cores = 4, chains = 2, backend = "cmdstanr", 
              control = list(adapt_delta = 0.95, max_treedepth = 15), refresh = 0)
    # summary(mod2)
    data$NEE_mod2 <- fitted(mod2, newdata=data)[, "Estimate"]
    
    ER_model_performance[isite_year, 5:6] <- postResample(pred=data$NEE_mod2[idx], obs=data$NEE[idx])[1:2]
    # 
    # ######################Model 3: Quadratic exponential with water term only
    if (site_info$SWC_use[id] == 'YES') {
      mod3 <- brms::brm(brms::bf(frmu[[3]], alpha+beta+C0+Hs ~ 1, nl = TRUE),
                        prior = stprm[[3]], data = data, iter = 2000, cores = 4, chains = 2, backend = "cmdstanr", 
                        control = list(adapt_delta = 0.95, max_treedepth = 15), refresh = 0)
      # summary(mod3)
      data$NEE_mod3 <- fitted(mod3, newdata=data)[, "Estimate"]
      ER_model_performance[isite_year, 7:8] <- postResample(pred=data$NEE_mod3[idx], obs=data$NEE[idx])[1:2]
    }
    ######################Model 4: Quadratic exponential with daytime NEE term only   
    mod4 <- brms::brm(brms::bf(frmu[[4]], alpha+beta+C0+k2 ~ 1, nl = TRUE),
                      prior = stprm[[4]], data = data, iter = 2000, cores = 4, chains = 2, backend = "cmdstanr", 
                      control = list(adapt_delta = 0.95, max_treedepth = 15), refresh = 0)
    # print(summary(mod4))
    data$NEE_mod4 <- fitted(mod4, newdata=data)[, "Estimate"]
    ER_model_performance[isite_year, 9:10] <- postResample(pred=data$NEE_mod4[idx], obs=data$NEE[idx])[1:2]
    
    ######################Model 5: Quadratic exponential with both water and daytime NEE term
    if (site_info$SWC_use[id] == 'YES') {
      for (ifrmu in 5:length(frmu)) {
        mod5 <- brms::brm(brms::bf(frmu[[ifrmu]], alpha+beta+C0+Hs+k2+gamma ~ 1, nl = TRUE),
                          prior = stprm[[ifrmu]], data = data, iter = 2000, cores = 4, chains = 2, backend = "cmdstanr", 
                          control = list(adapt_delta = 0.95, max_treedepth = 15), refresh = 0)
          
        data$NEE_mod5 <- fitted(mod5, newdata=data)[, "Estimate"]
        ER_model_performance[isite_year, 2 + (ifrmu*2-1):(ifrmu*2) ] <- postResample(pred=data$NEE_mod5[idx], obs=data$NEE[idx])[1:2]
      }
    }
  }
  # print(colMeans(ER_model_performance[(isite_year - iEnd + iStart + 1):isite_year, 3:20]))

}

write.csv(result, 'data/ER_model_comparison.csv', row.names = FALSE)

result <- colMeans(ER_model_performance[!is.na(ER_model_performance$V42), -c(1:2)], na.rm=T)
df <- data.frame(RMSE = result[seq(1, 40, by=2)], R2 =result[seq(2, 40, by=2)])

#
# brms::fixef(mod5, summary = TRUE)[, "Estimate"]
